
\chapter[Éléments de programmation]{Éléments de programmation}
Dans ce chapitre sont présentés les technologies, paradigmes
et techniques liés à l'implémentation informatique de
l'application. Notamment, lesquelles ont été utilisées,
comment elles fonctionnent et, une à une, comment cela
s’est traduit dans l'implémentation final de l'application.
Les exemples de codes sont tirés de l'application.

\section{Choix des technologies}
Le développement d'applications
pour smartphones est, depuis un peu plus d'une décennie, en pleine effervescence. Il existe, par
conséquent, une multitude de frameworks, services, langages, méthodologies et paradigmes liés à leur
développement.

Ces technologies aux noms exotiques, aux logos plus brillants les uns que les autres et aux
conférences accrocheuses qui leur sont dédiées, font que leurs différences relèvent plus
d'une stratégie marketing visant les informaticiens, réussie que des attributs
intrinsèques de la technologie en question.

L'application étant d'une complexité modérée et ne demandant pas de ressources importantes
comme tel pourrait être le cas pour une messagerie instantanée à grand échelle ou une application
utilisant abondamment un domaine spécifique de connaissance comme le machine learning, le traitement d'images, les jeux vidéo, etc.
Exclu \textit{de facto} le choix d'une technologie basée exclusivement sur les performances ou sur le développement natif.

N'ayant jamais fait cela auparavant, il n'y a aucune préférence de ma part pour telle ou telle technologie.

Ces constats donnent lieu aux critères de sélection suivants:
\smallskip
\begin{itemize}
    \item Développement cross-plateforme
    \item Simplicité
    \item Apprentissage d'un langage plutôt qu'une multitude
    \item Vaste documentation et ressources d'apprentissage
\end{itemize}
\smallskip
Le premier critère est celui qui réduit le plus la liste des possibilités. En effet, les frameworks
permettant le développement d'applications pour Android et IOS ne se comptent pas en grand nombre. Il existe\footnote{Liste non exhaustive}:
\smallskip
\begin{itemize}
    \item Xamarin - Microsoft
    \item React Native - Facebook
    \item Flutter - Google
    \item Adobe PhoneGap - Adobe
    \item Ionic - MIT
\end{itemize}
\smallskip
Le choix parmi ces possibilités découle essentiellement de l'arbitraire. Toutefois, Ionic a été exclu car il est nécessaire de maîtriser HTML5 et par conséquent CSS mais encore Angular JS. Ce qui contredit le 3ème critère.

React native a été exclu pour des raisons similaires. I.e. l'apprentissage de divers langages.

Finalement, à la suite d’un cours de Academind d'une durée de 40 heures portant sur les aspects les plus basiques du développement jusqu'au déploiement de l'application en passant par le routage, la gestion de requêtes http, la connexion à tout un écosystème de bases de données, l'utilisation de caméra et géolocalisation, et même sur comment changer le logo de l'application, le choix s'est porté sur Flutter.

Flutter est un framework crée par Google. Ce dernier offre, pour les applications, le service Firebase qui englobe :

\smallskip
\begin{itemize}
    \item Cloud Firestore
    \item Real time database
    \item Functions
    \item Machine learning
    \item Cloud messaging
    \item \dots
\end{itemize}
\smallskip
Firebase s'intègre, par conception, particulièrement bien et facilement à Flutter. Même s'ils sont
indépendants, leurs utilisation conjointe forme un seul écosystème plus facile à appréhender. Ainsi pour la
base de données, le choix a été la Real time database. Car cette dernière fournit une API REST.

De plus, toujours dans cet écosystème, \textit{Cloud messaging} est utilisé pour l'envoi des notifications et \textit{Functions} pour
effectuer des actions côté serveur lorsque la base de données subit des modifications.

\section{Flutter}
Flutter est un \textit{Software Developpement Kit} (SDK) développé par Google permettant de concevoir
des applications pour plusieurs plateformes. Notamment, Android et IOS avec un seul code source.

Fluter est aussi et surtout un framework. Il se caractérise par le fait qu'il va principalement dessiner des éléments
à l'écran en se basant sur les pixels. Ainsi, il n'utilise pas, de base, de librairies natives. Par exemple, pour dessiner un
bouton, il ne va pas faire appel au primitives bouton dans Android ou IOS mais va dessiner pixel par pixel
l'objet souhaité.

\subsection{Dart}
Dart est le langage de programmation avec lequel certains éléments du framework ont été développé mais il s'agit
surtout du langage dans lequel on implémente une application en Flutter.

C'est un langage orienté objet avec un syntaxe de type C à l'image d'autres langages comme Java ou C++.
Sa syntaxe est proche du Java.

Il partage certaines fonctionnalités propres au langages fonctionnels. Notamment, l'inférence de type ou encore
certaines fonctionnalités comme les \textit{map}, \textit{functors} \dots

En Dart, l'allocation de mémoire est gérée automatiquement et sa libération est faite par un garbage collector.

Voici un exemple minimal d'un \textit{Hello world} en Dart:
\begin{listing}[!h]
    \begin{minted}{dart}
            void main() => print('Hello, World!');
        \end{minted}
    \label{code:helloWorld}
    \caption{Hello world}
\end{listing}
\newpage

\subsection{Architecture}
Pour mieux comprendre les différents éléments de programmation qui vont suivre, il est intérressant de s'attarder
un peu sur l'architcture interne du framework.
Flutter a un architecture en couches (\textit{layers}).
\begin{figure}[!h]
    \begin{center}
        \begin{tikzpicture}
            \node (material) [start] {material};
            \node (cupertino) [start, right of=material, xshift=2cm] {cupertino};
            \node (widgets) [start, below of=material, minimum width=6cm, xshift=1.5cm] {widgets};
            \node (render) [start, below of=widgets, minimum width=6cm] {rendering};
            \node (animation) [start, below of=render, minimum width=2cm, xshift=-2cm] {animation};
            \node (paint) [start, right of=animation, minimum width=2cm, xshift=1cm ] {painting};
            \node (gestures) [start, right of=paint, minimum width=2cm, xshift=1cm] {gestures};
            \node (fundation) [start, below of=animation, minimum width=6cm, xshift=2cm] {foundation};
        \end{tikzpicture}
    \end{center}
    \caption{Layers du Framework Flutter}
    \label{fig:layers}
\end{figure}

Le \textit{layer} \textit{foundation} offre les clases de bases du framework sans avoir à tenir compte
de l'\textit{engine} écrit en C++ qui se trouve en dessous. Il offre aussi, au moyen de \textit{animation}, \textit{painting}
et \textit{gestures} les bases pour l'animation, le dessin et la detection de mouvement sur l'écran.

Le \textit{layer} \textit{rendering} offre une abstraction permettant de gérer l'affichage des éléments.
Il va construire des objets (dérivés des widgets principalement) organisés sous forme d'arbre dynamique qui peuvent être affichés à l'écran.

Le \textit{layer} \textit{widgets} est une abstraction au dessus de \textit{rendering} qui respecte le pattern de conception composite. Ainsi, chaque objet dans le \textit{layer} \textit{rendering}
lui correspond une classe dans le \textit{layer} \textit{widgets}.

Le \textit{layer} \textit{material} et \textit{cupertino} sont un ensemble de classes prédéfinies et personalisables qui implémentent tout un catalogue
de widgets avec respectivement le style material design d'Android et le design propre à IOS.

\subsection{Les widgets}
Les widgets dans Flutter sont les éléments avec lesquels le programmeur à le plus de contact. Ils sont en effet, le composant principal d'une application
Flutter. Voici un exemple:

\begin{listing}[!h]
    \begin{minted}{dart}
            Text(
                  "Crazy Wolf",
                  style: TextStyle(fontSize: 26, fontFamily: "Anton"),
                ),
        \end{minted}
    \caption{Widget Text}
    \label{code:textWidget}
\end{listing}

Comme le code le sous-entend, les widgets peuvent s'encapsuler les uns dans les autres. Ainsi,
Le widget \textit{Text} accepte dans sont constructeur une chaine de caractères "Crazy Wolf" et un style qui est lui-même un
widget \textit{TextStyle}. À son tour, il accepte, entre autres, une taille et une police d'écriture en argument.

Cette encapsulation n'est pas un choix arbitraire mais trahi, comme vu auparavant, l'architecture du framework. En effet,
Le \textit{layer} \textit{rendering} est un arbre dynamique de widgets (pas seulement) et le \textit{layer} \textit{widgets}
respecte le pattern composite. Ainsi, il est naturel que les widgets se composent.

On en déduit que Flutter est un framework déclaratif plutôt	qu'impératif. En effet, plutôt que de modifier des instances d'objets existants
afin de varier l'affichage, Flutter construit de nouvelles instances de widgets selon les besoins.

La philosophie sous-jacente du framework est de composer de petits widgets aux fonctionnalités de bases afin de
créer une fonctionalité complexe.

Le terme widget englobe une multitude de verbes. Un widget peut ne pas avoir de représentation en tant que tel
mais peut offrire un positionement, une transformation, une taille, interaction ave l'utilisateur, animation,~\dots

Par exemple, le widget \textit{Center} centre un autre widget en argument au centre de l'écran, dans la mesure de l'espace restant disponible.
\begin{listing}[h]
    \begin{minted}{dart}
            Center(child: Text(...),),
        \end{minted}
    \caption{Widget Center}
    \label{code:center}
\end{listing}

Les widget sont des classes immutables, c'est-à-dire qu'une fois l'objet instancié, il n'est plus possible d'en modifier le contenu.
Il existe essentiellement deux types de widgets dans Flutter: ceux qui on un état: \textit{StatefulWidget} et ceux qui n'ont en pas:
les \textit{StatelessWidget}.

\subsubsection*{StatelessWidget}
Ce sont les widgets dont les propriétés ne varient pas dans le temps. Par exemple:

\begin{listing}[h]
    \begin{minted}{dart}
            import 'package:flutter/material.dart';
            class ScreenSplash extends StatelessWidget {
                @override
                Widget build(BuildContext context) {
                    return Scaffold(body: Center(child: CircularProgressIndicator(),),);}}
        \end{minted}
    \caption{Exemple \textit{stateless}}
    \label{code:statelessExample}
\end{listing}

Ici, \textit{ScreenSplash} hérite de \textit{StatelessWidget}. Afin, de déterminer la représentation visuelle d'un widget,
il faut \textit{override} la méthode \textit{build()} de \textit{StatelessWidget}. Ainsi, \textit{ScreenSplash} retourne un \textit{Scaffold}
qui est un écran d'affichage basique respectant le style material design. À son tour,
\textit{Scaffold} a une bare de progression circulaire (le \textit{CircularProgressIndicator}) au centre (\textit{Center}) de l'écran.

Cette classe représente l'écran affiché à chaque fois qu'une requête à la base de données se fait. Elle permet à l'utilisateur de savoir qu'une action
est en cours et qu'il doit patienter.
\newpage
\subsubsection*{StatefulWidget}
Ce sont les widgets dont les propriétés peuvent varier dans le temps. Ces widgets ont un état, or ils sont immutable. C'est pourquoi ils sauvegardent
l'état dans une classe séparée  sous-classe de \textit{State}.

Quand l'état change à l'aide de l'appel de fonction \textit{setState()}, la méthode \textit{build} est appelée et l'interface est mise-à-jour. En guise d'exemple, voici une partie du code source
de l'écran \textit{Horaires} \ref{fig:horaires}. Notamment, le petit menu inférieur permettant d'afficher tous les horaires ou seulement ceux de l'utilisateur authentifié.
\begin{listing}[h]
    \begin{minted}{dart}
class ScreenScheduleView extends StatefulWidget {
    @override
    _ScreenScheduleViewState createState() => _ScreenScheduleViewState();
    }
    class _ScreenScheduleViewState extends State<ScreenScheduleView> {
    var _selectedIndex = 0;
    
    void _onItemTapped(int index) {
        setState(() {_selectedIndex = index;});
    }
        \end{minted}
    \caption{Screen Horaires}
    \label{code:screenHoraires}
\end{listing}

La classe \textit{ScheduleView} hérite d'un \textit{StatefulWidget}. Dans la classe d'état il y a l'attribut: \textit{selectedIndex}. L'indice selectionné a pour valeur 0 à la construction de l'instance.
Si la fonction \textit{onItemTapped(int index)} est appellée avec un entier en argument alors, à l'aide de la fonction \textit{setState} l'état est modifié
et la fonction \textit{build()} de \textit{ScreenScheduleViewSate} est appelée. Ainis le \textit{widget} est reconstruit en fonction de son nouvel état.

\begin{listing}[h]
    \begin{minted}{dart}
@override
Widget build(BuildContext context) {
    return Scaffold(
    bottomNavigationBar: BottomNavigationBar(
        onTap: _onItemTapped,
        currentIndex: _selectedIndex,
        items: const [
            BottomNavigationBarItem(
            icon: Icon(Icons.person),
            title: Text("Mes services")),
            BottomNavigationBarItem(
            icon: Icon(Icons.list),
            title: Text("Tous les horaires"))]),
        \end{minted}
    \caption{build() de ScheduleView}
    \label{code:buildHoraire}
\end{listing}

Scaffold accepte un menu de navigation au bas de la page. Celui-ci est un widget: \textit{BottomNavigationBar}. Ce widget prend en construction:
\begin{itemize}
    \item une fonction qui est appelée lorsque une \textit{tap} a été detecté sur l'un des deux icons définis dans la liste \textit{Items}.
    \item un index qui définit lequel des éléments de la liste est actuellement séléctionné.
    \item une liste de \textit{widgets} de type \textit{BottomNavigationBarItem}.
\end{itemize}
Le premier élément de la liste i.e. "Mes services" a pour index 0. Et "Tous les horaires" 1. Par défaut, \textit{selectedIndex} vaut 0. Dans un premier temps c'est "Mes services" qui est affiché.

Lorsque l'utilisateur clic sur un icône , \textit{BottomNavigationBar} va appeler la fonction \textit{onItemTapped} définie dans le code \ref{code:screenHoraires} avec
l'index de l'icône en question en argument. \textit{onItemTapped} va changer l'état du widget et par extension la valeur de \textit{selectedIndex}. L'état ayant changer la fonction
\textit{build} est appelée et donc \textit{BottomNavigationBar} redessiné avec un \textit{currentIndex} potentiellement différent. Traduisant ainsi
un affichage différent et l'ion sélectionné apparaîtrait en orange.

\subsection{Flux de données}
Dans la partie précédente, on constate que la gestion de l'état des widgets peut vite devenir encombrante. En effet, dans l'exemple,
l'utilisation d'un \textit{StatefulWidget} est naturelle, l'information étant un index n'est ni complexe ni lourde. Or comment, partager des
données complexes entre les différents widgets?

En général on fait la distinction entre l'état éphémère et l'état de l'application.
\smallskip
\begin{itemize}
    \item L'état éphémère est celui qui peut entièrement être définit au sein d'un widget. Il n'a pas ou peu besoin d'être
          accédé à l'extérieur du widget et il ne varie pas de façon complexe.
    \item L'état de l'application est celui qui à l'inverse, peu se modifier de façon complexe, doit être préservé lorsque l'application est fermée,
          contient de vastes informations et doit être partagé parmi divers widgets. Comme par exemple, la liste des serveurs, la liste des services, les
          données d'authentification~\dots
\end{itemize}

Il existe de nombreuse techniques pour la gestion du flux de données dans les applications et en informatique en général. Pour cette application, 3 façons
on été utilisées.

Pour transmettre les données d'un widget à ses enfants soit la transmission s'est faite par constructeur soit à l'aide des classes \textit{ChangeNotifier}, \textit{ChangeNotifierProvider} et \textit{Consumer}.

Pour transmettre les données d'un enfant à un parent, les callbacks on été utilisés.

\subsubsection{Par constructeur}
Il s'agit à la fois de la méthode la plus répandue comme la plus simple. Voici un exemple:

\begin{listing}[h]
    \begin{minted}{dart}
class ScheduleCard extends StatelessWidget {
  final bool doesUserWorkIn;
  final ServiceType stype;
  final List<Waiter> waiters;
  final List<Waiter> doublers;
  final Service service;
  
  const ScheduleCard({Key key, this.doesUserWorkIn, this.stype,
    this.waiters, this.doublers, this.service,}) : super(key: key);
    \end{minted}
    \caption{ScheduleCard, par constructeur}
    \label{code:scheduleCard}
\end{listing}
Cette classe \ref{code:scheduleCard} est celle qui se charge de dessiner un élément de la liste des horaires \ref{fig:horaires}. Son widget parent se charge de générer la liste dans son ensemble ainsi que d'autres implémentations de la logique de l'application. De plus, le parent transmet par constructeur à \textit{ScheduleCard} les informations suivantes:
\smallskip
\begin{itemize}
    \item [doesUserWorkIn] : une variable booléenne indiquant si l'utilisateur actuellement authentifié travail dans le service en question. Ceci permet de changer la couleur de fond (orange ou blanc).
    \item [type] : le type de service i.e midi ou soir.
    \item [waiters]: la liste des objets serveurs qui y travaillent.
    \item [doublers]: la liste des objets serveurs qui doublent dans ce service.
    \item [service]: l'objet service en question.
\end{itemize}
\smallskip

Ainsi chaque \textit{Card} ou élément de la liste est un instance de l'objet \textit{ScheduleCard}. On constat que les attributs sont \textit{final} ce qui veut dire qu'il sont constant au \textit{runtime}. Donc chaque instance de \textit{card} est immutable. Ainsi, une nouvelle instance doit remplacer la précédente si l'on souhaite mettre-à-jour l'interface. 

\subsubsection{ChangeNotifier+Provider +  \& Consumer}

Théoriquement, rien n'empêche de transmettre toutes les informations par constructeur. Toutefois, l'arborescence des widgets devient rapidement profonde
et dans la situation où une certaine information est nécessaire au niveau \(n\) mais aussi au niveau \(n+i, i > 1\) il serait nécessaire de transmettre l'information
dans tous les widgets intermédiaires alors qu'ils n'en n'ont pas besoin.

De plus, si une information n'est utile que tout en bas de l'arborescence et qu'elle a été transmise par constructeur, alors tous les widgets intermédiaires seront reconstruit inutilement.

\emph{ChangeNotifier}\\
Il s'agit d'une classe dans Flutter qui implémente un objet de type \textit{Listenable} du même framework. En somme, c'est une implémentation du pattern \textit{Observer}\footnote{https://en.wikipedia.org/wiki/Observer\_pattern}. Ainsi, il est possible d'utiliser \textit{ChangeNotifier} lorsqu'une classe, susceptible de muter, doit notifier d'autres objets de ses modifications internes. 

La classe Pool, celle qui gère la liste des \textit{PoolItem} - objets représentant un élément en bourse - utilise \textit{ChangeNotifier}.
\begin{listing}[!h]
    \begin{minted}{dart}
class Pool with ChangeNotifier {
  List<PoolItem> _pool;
  bool isLoaded = false;
  Pool(this._pool);
  // ...
}
\end{minted}
\caption{ChangeNotifier - mixin}
\label{code:changeNotifier}
\end{listing}

Le mot clef \textit{with} veut dire qu'il s'agit d'un \textit{mixin}. Les \textit{mixin} permettent de combler l'absence d'héritage multiple. Ainsi, il est possible de réutiliser du code d'une classe dans de multiples hiérarchies de classes. Attention, ce n'est pas une interface dont il faut implémenter les méthodes.
\newpage
Voici, concrètement comment ça s'utilise. \textit{deletePoolItem} est une méthode de la classe \textit{Pool}. Lorsqu'un service mis en bourse est supprimé, cette méthode est appelée. Il s'agit d'une méthode asynchrone qui retourne, dans un future, rien.

\begin{listing}[!h]
\begin{minted}{dart}
 Future<void> deletePoolItem(String poolId, token) async {
    try {
      await http.delete(UrlManager.pool_path(poolId) + token);
      _pool.removeWhere((p) => p.id == poolId);
      notifyListeners();
      return;
    } catch (error) {
      print("[deletePoolItem]:: " + error.toString());
    }
  }
\end{minted}
\caption{ChangeNotifier - notify}
\label{code:changeNotifierNotify}
\end{listing}

Comme on peut le voir, trois actions ont lieu:
\smallskip
\begin{itemize}
    \item Une requête de suppression dans la base de données.
    \item Supprime le \textit{Poolitem} de la liste.
    \item Notifie tous les \textit{observateurs} ou \textit{listeners} d'une modification.
\end{itemize}
\smallskip
Ce type de comportement a été implémenté dans diverses méthodes des classe suivantes: \textit{Pool}, \textit{Services}, \textit{Waiters} et \textit{Auth}.

Pour pouvoir disposer de l'information il faut fournir ces classes un niveau au dessus dans l'arborescence de là où leur contenu est utilisé. L'application n'est pas très complexe ainsi, la plupart des widgets qui utilisent ces diverses informations se situent directement en dessous du \textit{MyApp}.

\emph{ChangeNotifierProvider}

Voici une partie de la méthode \textit{build()} de \textit{MyApp} - le widget initial.
L'objet \textit{Multiprovider} est juste un \textit{syntactic sugar} pour éviter l'imbrication des divers \textit{Provider} dont dépend l'application.
\begin{listing}[!h]
\begin{minted}{dart}
 @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        ChangeNotifierProvider(
          create: (context) => Auth()),
        ChangeNotifierProvider<Services>(
          create: (context) => Services([])),
        ChangeNotifierProvider<Waiters>(
          create: (context) => Waiters([])),
        ChangeNotifierProvider<Pool>(
          create: (context) => Pool([])),
      ],
\end{minted}
\caption{Multiprovider}
\label{code:multiprovider}
\end{listing}

Le contenu des classes: \textit{Auth}, \textit{Services}, \textit{Waiters} et \textit{Pool} est maintenant disponible dans l'ensemble de l'application au travers du \textit{context}.

Le \textit{context} est une instance de \textit{BuildContext} qui se transmet de \textit{widget} en \textit{widget} leurs permettant de connaître leurs positions dans l'arborescence. Un usage courant du \textit{context} dans les applications Flutter est: \mint{dart}|Quelquechose.of(context);| permettant de retourner \textit{quelquechose} que le \textit{widget} le plus proche (relativement à celui qui fait l'appel) est en mesure de lui fournir.

\section{La base de données}
\subsection{La méthodologie REST}
\subsection{REST appliqué à Dart}


\section{Notifications}



\section{Sécurité}

\subsection{Authentification}

\subsection{Firebase rules}
