
\chapter[Éléments de programmation]{Éléments de programmation}
Dans ce chapitre sont présentés les technologies, paradigmes
et techniques liés à l'implémentation informatique de
l'application. Notamment, lesquelles ont été utilisées,
comment elles fonctionnent et, une à une, comment cela
s’est traduit dans l'implémentation final de l'application.
Les exemples de codes sont tirés de l'application.

\section{Choix des technologies}
Le développement d'applications
pour smartphones est, depuis un peu plus d'une décennie, en pleine effervescence. Il existe, par
conséquent, une multitude de frameworks, services, langages, méthodologies et paradigmes liés à leur
développement.

Ces technologies aux noms exotiques, aux logos plus brillants les uns que les autres et aux
conférences accrocheuses qui leur sont dédiées, font que leurs différences relèvent plus
d'une stratégie marketing visant les informaticiens, réussie que des attributs
intrinsèques de la technologie en question.

L'application étant d'une complexité modérée et ne demandant pas de ressources importantes
comme tel pourrait être le cas pour une messagerie instantanée à grand échelle ou une application
utilisant abondamment un domaine spécifique de connaissance comme le machine learning, le traitement d'images, les jeux vidéo, etc.
Exclu \textit{de facto} le choix d'une technologie basée exclusivement sur les performances ou sur le développement natif.

N'ayant jamais fait cela auparavant, il n'y a aucune préférence de ma part pour telle ou telle technologie.

Ces constats donnent lieu aux critères de sélection suivants:
\smallskip
\begin{itemize}
    \item Développement cross-plateforme
    \item Simplicité
    \item Apprentissage d'un langage plutôt qu'une multitude
    \item Vaste documentation et ressources d'apprentissage
\end{itemize}
\smallskip
Le premier critère est celui qui réduit le plus la liste des possibilités. En effet, les frameworks
permettant le développement d'applications pour Android et IOS ne se comptent pas en grand nombre. Il existe\footnote{Liste non exhaustive}:
\smallskip
\begin{itemize}
    \item Xamarin - Microsoft
    \item React Native - Facebook
    \item Flutter - Google
    \item Adobe PhoneGap - Adobe
    \item Ionic - MIT
\end{itemize}
\smallskip
Le choix parmi ces possibilités découle essentiellement de l'arbitraire. Toutefois, Ionic a été exclu car il est nécessaire de maîtriser HTML5 et par conséquent CSS mais encore Angular JS. Ce qui contredit le 3ème critère.

React native a été exclu pour des raisons similaires. I.e. l'apprentissage de divers langages.

Finalement, à la suite d’un cours de Academind d'une durée de 40 heures portant sur les aspects les plus basiques du développement jusqu'au déploiement de l'application en passant par le routage, la gestion de requêtes http, la connexion à tout un écosystème de bases de données, l'utilisation de caméra et géolocalisation, et même sur comment changer le logo de l'application, le choix s'est porté sur Flutter.

Flutter est un framework crée par Google. Ce dernier offre, pour les applications, le service Firebase qui englobe :

\smallskip
\begin{itemize}
    \item Cloud Firestore
    \item Real time database
    \item Functions
    \item Machine learning
    \item Cloud messaging
    \item \dots
\end{itemize}
\smallskip
Firebase s'intègre, par conception, particulièrement bien et facilement à Flutter. Même s'ils sont
indépendants, leurs utilisation conjointe forme un seul écosystème plus facile à appréhender. Ainsi pour la
base de données, le choix a été la Real time database. Car cette dernière fournit une API REST.

De plus, toujours dans cet écosystème, \textit{Cloud messaging} est utilisé pour l'envoi des notifications et \textit{Functions} pour
effectuer des actions côté serveur lorsque la base de données subit des modifications.

\section{Flutter}
Flutter est un \textit{Software Developpement Kit} (SDK) développé par Google permettant de concevoir
des applications pour plusieurs plateformes. Notamment, Android et IOS avec un seul code source.

Fluter est aussi et surtout un framework. Il se caractérise par le fait qu'il va principalement dessiner des éléments
à l'écran en se basant sur les pixels. Ainsi, il n'utilise pas, de base, de librairies natives. Par exemple, pour dessiner un
bouton, il ne va pas faire appel au primitives bouton dans Android ou IOS mais va dessiner pixel par pixel
l'objet souhaité.

\subsection{Dart}
Dart est le langage de programmation avec lequel certains éléments du framework ont été développé mais il s'agit
surtout du langage dans lequel on implémente une application en Flutter.

C'est un langage orienté objet avec un syntaxe de type C à l'image d'autres langages comme Java ou C++.
Sa syntaxe est proche du Java.

Il partage certaines fonctionnalités propres au langages fonctionnels. Notamment, l'inférence de type ou encore
certaines fonctionnalités comme les \textit{map}, \textit{functors} \dots

En Dart, l'allocation de mémoire est gérée automatiquement et sa libération est faite par un garbage collector.

Voici un exemple minimal d'un \textit{Hello world} en Dart:
\begin{listing}[!h]
    \begin{minted}{dart}
            void main() => print('Hello, World!');
        \end{minted}
    \label{code:helloWorld}
    \caption{Hello world}
\end{listing}
\newpage

\subsection{Architecture}
Pour mieux comprendre les différents éléments de programmation qui vont suivre, il est intérressant de s'attarder
un peu sur l'architcture interne du framework.
Flutter a un architecture en couches (\textit{layers}).
\begin{figure}[!h]
    \begin{center}
        \begin{tikzpicture}
            \node (material) [start] {material};
            \node (cupertino) [start, right of=material, xshift=2cm] {cupertino};
            \node (widgets) [start, below of=material, minimum width=6cm, xshift=1.5cm] {widgets};
            \node (render) [start, below of=widgets, minimum width=6cm] {rendering};
            \node (animation) [start, below of=render, minimum width=2cm, xshift=-2cm] {animation};
            \node (paint) [start, right of=animation, minimum width=2cm, xshift=1cm ] {painting};
            \node (gestures) [start, right of=paint, minimum width=2cm, xshift=1cm] {gestures};
            \node (fundation) [start, below of=animation, minimum width=6cm, xshift=2cm] {foundation};
        \end{tikzpicture}
    \end{center}
    \caption{Layers du Framework Flutter}
    \label{fig:layers}
\end{figure}

Le \textit{layer} \textit{foundation} offre les clases de bases du framework sans avoir à tenir compte
de l'\textit{engine} écrit en C++ qui se trouve en dessous. Il offre aussi, au moyen de \textit{animation}, \textit{painting}
et \textit{gestures} les bases pour l'animation, le dessin et la detection de mouvement sur l'écran.

Le \textit{layer} \textit{rendering} offre une abstraction permettant de gérer l'affichage des éléments.
Il va construire des objets (dérivés des widgets principalement) organisés sous forme d'arbre dynamique qui peuvent être affichés à l'écran.

Le \textit{layer} \textit{widgets} est une abstraction au dessus de \textit{rendering} qui respecte le pattern de conception composite. Ainsi, chaque objet dans le \textit{layer} \textit{rendering}
lui correspond une classe dans le \textit{layer} \textit{widgets}.

Le \textit{layer} \textit{material} et \textit{cupertino} sont un ensemble de classes prédéfinies et personalisables qui implémentent tout un catalogue
de widgets avec respectivement le style material design d'Android et le design propre à IOS.

\subsection{Les widgets}
Les widgets dans Flutter sont les éléments avec lesquels le programmeur à le plus de contact. Ils sont en effet, le composant principal d'une application
Flutter. Voici un exemple:

\begin{listing}[!h]
    \begin{minted}{dart}
            Text(
                  "Crazy Wolf",
                  style: TextStyle(fontSize: 26, fontFamily: "Anton"),
                ),
        \end{minted}
    \caption{Widget Text}
    \label{code:textWidget}
\end{listing}

Comme le code le sous-entend, les widgets peuvent s'encapsuler les uns dans les autres. Ainsi,
Le widget \textit{Text} accepte dans sont constructeur une chaine de caractères "Crazy Wolf" et un style qui est lui-même un
widget \textit{TextStyle}. À son tour, il accepte, entre autres, une taille et une police d'écriture en argument.

Cette encapsulation n'est pas un choix arbitraire mais trahi, comme vu auparavant, l'architecture du framework. En effet,
Le \textit{layer} \textit{rendering} est un arbre dynamique de widgets (pas seulement) et le \textit{layer} \textit{widgets}
respecte le pattern composite. Ainsi, il est naturel que les widgets se composent.

On en déduit que Flutter est un framework déclaratif plutôt	qu'impératif. En effet, plutôt que de modifier des instances d'objets existants
afin de varier l'affichage, Flutter construit de nouvelles instances de widgets selon les besoins.

La philosophie sous-jacente du framework est de composer de petits widgets aux fonctionnalités de bases afin de
créer une fonctionalité complexe.

Le terme widget englobe une multitude de verbes. Un widget peut ne pas avoir de représentation en tant que tel
mais peut offrire un positionement, une transformation, une taille, interaction ave l'utilisateur, animation,~\dots

Par exemple, le widget \textit{Center} centre un autre widget en argument au centre de l'écran, dans la mesure de l'espace restant disponible.
\begin{listing}[h]
    \begin{minted}{dart}
            Center(child: Text(...),),
        \end{minted}
    \caption{Widget Center}
    \label{code:center}
\end{listing}

Les widget sont des classes immutables, c'est-à-dire qu'une fois l'objet instancié, il n'est plus possible d'en modifier le contenu.
Il existe essentiellement deux types de widgets dans Flutter: ceux qui on un état: \textit{StatefulWidget} et ceux qui n'ont en pas:
les \textit{StatelessWidget}.

\subsubsection*{StatelessWidget}
Ce sont les widgets dont les propriétés ne varient pas dans le temps. Par exemple:

\begin{listing}[h]
    \begin{minted}{dart}
            import 'package:flutter/material.dart';
            class ScreenSplash extends StatelessWidget {
                @override
                Widget build(BuildContext context) {
                    return Scaffold(body: Center(child: CircularProgressIndicator(),),);}}
        \end{minted}
    \caption{Exemple \textit{stateless}}
    \label{code:statelessExample}
\end{listing}

Ici, \textit{ScreenSplash} hérite de \textit{StatelessWidget}. Afin, de déterminer la représentation visuelle d'un widget,
il faut \textit{override} la méthode \textit{build()} de \textit{StatelessWidget}. Ainsi, \textit{ScreenSplash} retourne un \textit{Scaffold}
qui est un écran d'affichage basique respectant le style material design. À son tour,
\textit{Scaffold} a une bare de progression circulaire (le \textit{CircularProgressIndicator}) au centre (\textit{Center}) de l'écran.

Cette classe représente l'écran affiché à chaque fois qu'une requête à la base de données se fait. Elle permet à l'utilisateur de savoir qu'une action
est en cours et qu'il doit patienter.
\newpage
\subsubsection*{StatefulWidget}
Ce sont les widgets dont les propriétés peuvent varier dans le temps. Ces widgets ont un état, or ils sont immutable. C'est pourquoi ils sauvegardent
l'état dans une classe séparée  sous-classe de \textit{State}.

Quand l'état change à l'aide de l'appel de fonction \textit{setState()}, la méthode \textit{build} est appelée et l'interface est mise-à-jour. En guise d'exemple, voici une partie du code source
de l'écran \textit{Horaires} \ref{fig:horaires}. Notamment, le petit menu inférieur permettant d'afficher tous les horaires ou seulement ceux de l'utilisateur authentifié.
\begin{listing}[h]
    \begin{minted}{dart}
class ScreenScheduleView extends StatefulWidget {
    @override
    _ScreenScheduleViewState createState() => _ScreenScheduleViewState();
    }
    class _ScreenScheduleViewState extends State<ScreenScheduleView> {
    var _selectedIndex = 0;
    
    void _onItemTapped(int index) {
        setState(() {_selectedIndex = index;});
    }
        \end{minted}
    \caption{Screen Horaires}
    \label{code:screenHoraires}
\end{listing}

La classe \textit{ScheduleView} hérite d'un \textit{StatefulWidget}. Dans la classe d'état il y a l'attribut: \textit{selectedIndex}. L'indice selectionné a pour valeur 0 à la construction de l'instance.
Si la fonction \textit{onItemTapped(int index)} est appellée avec un entier en argument alors, à l'aide de la fonction \textit{setState} l'état est modifié
et la fonction \textit{build()} de \textit{ScreenScheduleViewSate} est appelée. Ainis le \textit{widget} est reconstruit en fonction de son nouvel état.

\begin{listing}[h]
    \begin{minted}{dart}
@override
Widget build(BuildContext context) {
    return Scaffold(
    bottomNavigationBar: BottomNavigationBar(
        onTap: _onItemTapped,
        currentIndex: _selectedIndex,
        items: const [
            BottomNavigationBarItem(
            icon: Icon(Icons.person),
            title: Text("Mes services")),
            BottomNavigationBarItem(
            icon: Icon(Icons.list),
            title: Text("Tous les horaires"))]),
        \end{minted}
    \caption{build() de ScheduleView}
    \label{code:buildHoraire}
\end{listing}

Scaffold accepte un menu de navigation au bas de la page. Celui-ci est un widget: \textit{BottomNavigationBar}. Ce widget prend en construction:
\begin{itemize}
    \item une fonction qui est appelée lorsque une \textit{tap} a été detecté sur l'un des deux icons définis dans la liste \textit{Items}.
    \item un index qui définit lequel des éléments de la liste est actuellement séléctionné.
    \item une liste de \textit{widgets} de type \textit{BottomNavigationBarItem}.
\end{itemize}
Le premier élément de la liste i.e. "Mes services" a pour index 0. Et "Tous les horaires" 1. Par défaut, \textit{selectedIndex} vaut 0. Dans un premier temps c'est "Mes services" qui est affiché.

Lorsque l'utilisateur clic sur un icône , \textit{BottomNavigationBar} va appeler la fonction \textit{onItemTapped} définie dans le code \ref{code:screenHoraires} avec
l'index de l'icône en question en argument. \textit{onItemTapped} va changer l'état du widget et par extension la valeur de \textit{selectedIndex}. L'état ayant changer la fonction
\textit{build} est appelée et donc \textit{BottomNavigationBar} redessiné avec un \textit{currentIndex} potentiellement différent. Traduisant ainsi
un affichage différent et l'icon sélectionné apparaîtrait en orange.

\subsection{Flux de données}
Dans la partie précédente, on constate que la gestion de l'état des widgets peut vite devenir encombrante. En effet, dans l'exemple,
l'utilisation d'un \textit{StatefulWidget} est naturelle, l'information étant un index n'est ni complexe ni lourde. Or comment, partager des
données complexes entre les différents widgets?

En général on fait la distinction entre l'état éphémère et l'état de l'application.
\smallskip
\begin{itemize}
    \item L'état éphémère est celui qui peut entièrement être définit au sein d'un widget. Il n'a pas ou peu besoin d'être
          accédé à l'extérieur du widget et il ne varie pas de façon complexe.
    \item L'état de l'application est celui qui à l'inverse, peu se modifier de façon complexe, doit être préservé lorsque l'application est fermée,
          contient de vastes informations et doit être partagé parmi divers widgets. Comme par exemple, la liste des serveurs, la liste des services, les
          données d'authentification~\dots
\end{itemize}

Il existe de nombreuses techniques pour la gestion du flux de données dans les applications et en informatique en général. Pour cette application, 3 façons
ont été utilisées.

Pour transmettre les données d'un widget à ses enfants soit la transmission s'est faite par constructeur soit à l'aide des classes \textit{ChangeNotifier}, \textit{ChangeNotifierProvider} et \textit{Consumer}.

Pour transmettre les données d'un enfant à un parent, les callbacks on été utilisés.

\subsubsection{Par constructeur}
Il s'agit à la fois de la méthode la plus répandue comme la plus simple. Voici un exemple:

\begin{listing}[h]
    \begin{minted}{dart}
class ScheduleCard extends StatelessWidget {
  final bool doesUserWorkIn;
  final ServiceType stype;
  final List<Waiter> waiters;
  final List<Waiter> doublers;
  final Service service;
  
  const ScheduleCard({Key key, this.doesUserWorkIn, this.stype,
    this.waiters, this.doublers, this.service,}) : super(key: key);
    \end{minted}
    \caption{ScheduleCard, par constructeur}
    \label{code:scheduleCard}
\end{listing}
Cette classe \ref{code:scheduleCard} est celle qui se charge de dessiner un élément de la liste des horaires \ref{fig:horaires}. Son widget parent se charge de générer la liste dans son ensemble ainsi que d'autres implémentations de la logique de l'application. De plus, le parent transmet par constructeur à \textit{ScheduleCard} les informations suivantes:
\smallskip
\begin{itemize}
    \item [doesUserWorkIn] : une variable booléenne indiquant si l'utilisateur actuellement authentifié travail dans le service en question. Ceci permet de changer la couleur de fond (orange ou blanc).
    \item [type] : le type de service i.e midi ou soir.
    \item [waiters]: la liste des objets serveurs qui y travaillent.
    \item [doublers]: la liste des objets serveurs qui doublent dans ce service.
    \item [service]: l'objet service en question.
\end{itemize}
\smallskip

Ainsi chaque \textit{Card} ou élément de la liste est un instance de l'objet \textit{ScheduleCard}. On constat que les attributs sont \textit{final} ce qui veut dire qu'il sont constant au \textit{runtime}. Donc chaque instance de \textit{card} est immutable. Ainsi, une nouvelle instance doit remplacer la précédente si l'on souhaite mettre-à-jour l'interface. 

\subsubsection{ChangeNotifier+Provider \& Consumer}

Théoriquement, rien n'empêche de transmettre toutes les informations par constructeur. Toutefois, l'arborescence des widgets devient rapidement profonde
et dans la situation où une certaine information est nécessaire au niveau \(n\) mais aussi au niveau \(n+i, i > 1\) il serait nécessaire de transmettre l'information
dans tous les widgets intermédiaires alors qu'ils n'en n'ont pas besoin.

De plus, si une information n'est utile que tout en bas de l'arborescence et qu'elle a été transmise par constructeur, alors tous les widgets intermédiaires seront reconstruit inutilement.

\emph{ChangeNotifier}\\
Il s'agit d'une classe dans Flutter qui implémente un objet de type \textit{Listenable} du même framework. En somme, c'est une implémentation du pattern \textit{Observer}\footnote{https://en.wikipedia.org/wiki/Observer\_pattern}. Ainsi, il est possible d'utiliser \textit{ChangeNotifier} lorsqu'une classe, susceptible de muter, doit notifier d'autres objets de ses modifications internes. 

La classe \textit{Pool}, celle qui gère la liste des \textit{PoolItem} - objets représentant un élément en bourse - utilise \textit{ChangeNotifier}.
\begin{listing}[!h]
    \begin{minted}{dart}
class Pool with ChangeNotifier {
  List<PoolItem> _pool;
  bool isLoaded = false;
  Pool(this._pool);
  // ...
}
\end{minted}
\caption{ChangeNotifier - mixin}
\label{code:changeNotifier}
\end{listing}

Le mot clef \textit{with} veut dire qu'il s'agit d'un \textit{mixin}. Les \textit{mixin} permettent de combler l'absence d'héritage multiple. Ainsi, il est possible de réutiliser du code d'une classe dans de multiples hiérarchies de classes. Attention, ce n'est pas une interface dont il faut implémenter les méthodes.
\newpage
Voici, concrètement comment ça s'utilise. \textit{deletePoolItem} est une méthode de la classe \textit{Pool}. Lorsqu'un service mis en bourse est supprimé, cette méthode est appelée. Il s'agit d'une méthode asynchrone qui retourne, dans un future, rien.

\begin{listing}[!h]
\begin{minted}{dart}
 Future<void> deletePoolItem(String poolId, token) async {
    try {
      await http.delete(UrlManager.pool_path(poolId) + token);
      _pool.removeWhere((p) => p.id == poolId);
      notifyListeners();
      return;
    } catch (error) {
      print("[deletePoolItem]:: " + error.toString());
      throw error;
    }
  }
\end{minted}
\caption{ChangeNotifier - notify}
\label{code:changeNotifierNotify}
\end{listing}

Comme on peut le voir, trois actions ont lieu:
\smallskip
\begin{itemize}
    \item Une requête de suppression dans la base de données.
    \item Supprime le \textit{Poolitem} de la liste.
    \item Notifie tous les \textit{observateurs} ou \textit{listeners} d'une modification.
\end{itemize}
\smallskip
Ce type de comportement a été implémenté dans diverses méthodes des classes suivantes: \textit{Pool}, \textit{Services}, \textit{Waiters} et \textit{Auth}.

Pour pouvoir disposer de l'information il faut fournir ces classes un niveau au dessus dans l'arborescence de là où leur contenu est utilisé. L'application n'est pas très complexe ainsi, la plupart des widgets qui utilisent ces diverses informations se situent directement en dessous du \textit{MyApp}.

\emph{ChangeNotifierProvider}

Voici une partie de la méthode \textit{build()} de \textit{MyApp} - le widget initial.
L'objet \textit{Multiprovider} est juste un \textit{syntactic sugar} pour éviter l'imbrication des divers \textit{Provider} dont dépend l'application.
\begin{listing}[!h]
\begin{minted}{dart}
 @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        ChangeNotifierProvider(
          create: (context) => Auth()),
        ChangeNotifierProvider<Services>(
          create: (context) => Services([])),
        ChangeNotifierProvider<Waiters>(
          create: (context) => Waiters([])),
        ChangeNotifierProvider<Pool>(
          create: (context) => Pool([])),
      ],//...
\end{minted}
\caption{Multiprovider}
\label{code:multiprovider}
\end{listing}

Le contenu des classes: \textit{Auth}, \textit{Services}, \textit{Waiters} et \textit{Pool} est maintenant disponible dans l'ensemble de l'application au travers du \textit{context}.

Le \textit{context} est une instance de \textit{BuildContext} qui se transmet de \textit{widget} en \textit{widget} leurs permettant de connaître leurs positions dans l'arborescence. Un usage courant du \textit{context} dans les applications Flutter est: \mint{dart}|Quelquechose.of(context);| permettant de retourner \textit{quelquechose} que le \textit{widget} le plus proche (relativement à celui qui fait l'appel) est en mesure de fournir.

Maintenant que l'information est disponible et qu'elle est mise-à-jour si on interagit avec elle, il faut en disposer. 

\emph{Provider}

C'est une des façons d'accéder aux différentes ressources mises à disposition. Par exemple, lorsque un remplaçant est accepté dans l'écran \textit{poolDetails}, cette fonction ci-dessous est appelée au moment ou le bouton est pressé.

\begin{listing}[!h]
\begin{minted}{dart}
 Future<void> _accept(context, appId) async {
    var auth = Provider.of<Auth>(context, listen: false);
    try {
      await Provider.of<Pool>(context, listen: false)
          .selectApplicant(_poolItem.id, appId, auth.token);
      return;
    }//...
  }
\end{minted}
\caption{Provider of - example}
\label{code:providerOf}
\end{listing}

Le premier \textit{Provider} retourne une l'instance de la classe \textit{Auth} contenant divers attributs et méthodes liés à l'authentification des utilisateurs. Entre autres, le \textit{token} d'identification nécessaire pour les requêtes à la base de données. Cela sera discuté plus en détails dans la section authentification. 

Le deuxième \textit{Provider} donne accès à la ressource \textit{Pool} ainsi qu'à ses méthodes. Dont une est utilisé. \textit{selectApplicant} permet avec les identifiants d'un élément en bourse est d'un serveur y ayant postulé, de conclure la transaction en acceptant le postulant. 

Cette distinction entre la logique relative à la base de données, l'affichage et la logique utilisateur permet un code réutilisable et plus performant. Tout widget/bouton permettant d'accepter un postulant par exemple, peut appeler le \textit{Provider} et utiliser les méthodes de la ressource adéquate.
\newpage
\emph{Consumer}

Le widget \textit{Consumer} permet de "consommer" les ressources. Voici un exemple où \textit{Pool} est consommé. 

\begin{listing}[!h]
\begin{minted}{dart}
//...
Consumer<Pool>(
  builder: (context, pData, _) {
    var pool = pData.pool;
    if (pool.isEmpty) {
      return Center(child: Text("Aucun service en bourse pour l'instant"),);
    }//...
\end{minted}
\caption{ScreenPool: Pool Consumer}
\label{code:poolConsumer}
\end{listing}

Il est nécessaire de spécifier le type de la ressource, le \textit{provider} en a besoin pour discriminer. L'argument \textit{builder} est obligatoire. C'est la fonction qui sera appelé à chaque fois que le \textit{ChangeNotifier} change i.e la classe \textit{Pool} qui contient des \textit{PoolItem}. 

L'écran \textit{Bourse aux jobs} est intimement lié aux éléments \textit{PoolItem}. De ce fait, certaines modifications de ceux-ci doivent traduire un changement dans l'interface. 

Dans cet exemple, si la liste des \textit{PoolItem} est vide, alors un écran indiquant qu'il n'y a aucun élément en bourse s'affiche. Ce \textit{builder} sera appelé pour tout \textit{notifyListeners()} présent dans le code de la classe \textit{Pool}. Par exemple, accepter un postulant notifie les \textit{listeners}, provoque l'appel de cette fonction et l'affichage se modifie pour indiquer que l'élément nécessite validation d'un administrateur.

Un autre exemple de \textit{Consumer} est celui de \textit{Auth}. En effet, l'affichage de l'application change radicalement suivant si l'utilisateur est authentifié ou pas. De plus, si au cours de l'utilisation cela vient à changer, l'entièreté de l'UI\footnote{User Interface - Interface Utilisateur} doit changer. Voici un autre extrait de la fonction \textit{build} de la classe \textit{MyApp}:

\begin{listing}[!h]
\begin{minted}{dart}
//...
 child: Consumer<Auth>(
    builder: (ctx, auth, _) {//...
      return MaterialApp(
        title: 'Crazy Wolf',//...
        home: auth.isAuth
            ? ScreenSchedule()
            : FutureBuilder(future: auth.tryAutoLogin(),
                builder: (ctx, authResultSnapshot) =>
                    authResultSnapshot.connectionState == ConnectionState.waiting
                        ? ScreenSplash()
                        : ScreenAuth(),), //...
\end{minted}
\caption{ScreenPool: Auth Consumer}
\label{code:authConsumer}
\end{listing}

\textit{Auth} est consommé. Si l'utilisateur est authentifié alors on affiche l'écran \textit{Horaires}. Sinon, on essaye de s'auto-connecter. Si l'opération réussi, les \textit{listeners} sont notifiés ce qui implique que cette fonction est appelée à nouveau et à la question \textit{Auth.isAuth} la réponse sera vraie. Si l'opération d'auto-connexion échoue, alors l'écran de \textit{login} est affiché.

\subsection*{Callbacks}
Un \textit{callback} est par définition une fonction ou méthode qui est donnée en argument à une autre fonction ou méthode. 
Dans cette application les \textit{callbacks} ont été utilisés pour transmettre une valeur d'un \textit{widget} enfant à son parent sans en changer l'état. 

Prennons, l'example de l'écran \textit{Ajouter service} qui va se charger de faire la requête à la base de donnée avec toutes les information qui permettent d'y ajouter un service. Pour la construction de cette écran, il y a un parent \textit{Statefull widget} : \textit{ScreenAddService} et plusieurs enfants. Parmis ces enfants, seul le \textit{widget} \textit{TypeSelector} sera ilustré. En effet, ils implémentent tous le même mécanisme et les seules variations sont de type graphiques.

Voici un extrait de la classe \textit{ScreenAddService}:
\begin{listing}[!h]
\begin{minted}[fontsize=\scriptsize]{dart}
class _ScreenAddServiceState extends State<ScreenAddService> {
    ServiceType _selectedType;//...
    TypeSelector(
        (val) {
            return _selectedType = val; },//...
}
\end{minted}
\caption{AddService callBack}
\label{code:addServiceCallback}
\end{listing}

Cette classe a un attribut de type \textit{ServiceType}. A l'intérieur de cette classe, un \textit{widget} \textit{TypeSelector} dessinne les boutons "midi" et "soir" est créé. L'arguemnt fournit au constructeur est une fonction. Celle-ci prend un paramètre \textit{val} et retourne l'affectation de la valuer de \textit{val} dans l'attribut \textit{\_selectedType}. En d'autres termes, \textit{ScreenAddService} délègue l'affectation de son attribut \textit{\_selectedType} à l'objet de type \textit{TypeSelector}. 

\begin{listing}[!h]
\begin{minted}[fontsize=\scriptsize]{dart}
typedef ServiceValue = ServiceType Function(ServiceType);
class TypeSelector extends StatefulWidget {
  final ServiceValue select;
  TypeSelector(this.select); //...}
class _TypeSelectorState extends State<TypeSelector> {
  ServiceType currentSelectedType;
  @override
  Widget build(BuildContext context) {//...
        (type) => ChoiceChip(//...
            onSelected: (value) {
            setState(() { currentSelectedType = ServiceType(type); });
            widget.select(ServiceType(type));
            }, ),//...
\end{minted}
\caption{AddService callBack}
\label{code:TypeSelectorCallback}
\end{listing}
\textit{TypeSelctor} quant à lui définit un type : \textit{ServiceValue}. Ce type est une fonction qui prend en argument un \textit{ServiceType} et qui retourne la même chose. En effet, si l'on veut pouvoir faire l'affectation dans le \textit{widget} parent il faut que les types correspondent.

Finalement, cette fonction est assignée à la variable \textit{select}. Lorsqu'un utilisateur appuye sur l'un des \textit{ChoiceChip} - widgets chargés de dessiner les boutons - la fonction définie dans \textit{onSelected} est appelée avec le type séléctionné en argument. A la ligne 12, l'appel de la fonction déléguée est fait avec le susdit type. On constat que dans le widget enfant, la fonction \textit{setState} est aussi invoquée pour changer l'affichage des boutons.

\section{La base de données}
La base de données Real Time Database est une base de données non relationnelle. Les données sont stockées au format JSON. La base de donnée a trois objets: \textit{Waiters}, \textit{Services} et \textit{Pool}. Pour serveurs, services, et éléments en bourse respectivement.

Nous allons parcourir chacun d'entre eux dans l'ordre.

\subsection*{Waiters}
Il faut savoir que pour créer de nouveaux utilisateurs, il faut faire une requête \textit{POST} avec le nom d'utilisateur, l'email et le mot de passe à une url spéciale dédiée aux intéractions de type administrateur. Cette requête retourne un numéro d'identification (id). Ce sont ces identifiants qui vont permettre aux utilisateurs de se \textit{logger} à l'écran \ref{fig:login}. Ils sont crées uniquement à travers l'écran \ref{fig:ajout_serveur}.

Dans cette implémentation, les utilisateurs et les serveurs (\textit{waiters}) représentent la même entité.

Une fois que la création de l'utilisateur a réussie et que l'on dipose de son id, une deuxième requête \textit{POST}, cette fois ci, à la base de données, est faite. Cette deuxième requête doit respecter le schéma suivant : 

\begin{listing}[!h]
\begin{minted}[fontsize=\scriptsize]{json}
{
    "title": "Waiter",
    "type": "object",
    "required": [ "name", "sname", "role", "userId" ],
    "properties": {
        "name": {
            "type": "String",
            "description": "The user and waiter first name"
        },
        "sname":{
            "type": "String",
            "description": "The user and waiter second name"
        },
        "role": {
            "type": "String",
            "description": "credentials of the user. "
        },
        "userId": {
            "type": "String",
            "description": "id generated when signed"
        }   
    }
}
\end{minted}
\caption{JSON Schema Waiters}
\label{schema:waiters}
\end{listing}


Les propriétés correspondent aux champs dans \ref{fig:ajout_serveur}. Le \textit{userId} et le numéro d'indentification retourné par la première requête \textit{POST}.

Comme il est uniquement possible d'ajouter des serveurs en étant administrateur et que l'on connait le role d'un utilisateur en regardant dans la base de données, il a fallu que le premier serveur soit ajouté manuellement depuis le navigateur.
\newpage
\subsection*{Services}
Représentent les objets définissant un service. C'est-à-dire, une date, un type, les serveurs et doubleurs qui y travaillent. Les requêtes \textit{POST} pour populer la base de données doivent respecter le schéma suivant:

\begin{listing}[!h]
\begin{minted}[fontsize=\scriptsize]{json}
{
    "title": "Service",
    "type": "object",
    "required": [ "date", "id", "type", "waiterIds" ],
    "properties": {
        "date": {
            "type": "Iso: 8601 String",
            "description": "the date of the service"
        },
        "id":{
            "type": "String",
            "description": "autogenerated id of the service"
        },
        "type": {
            "type": "String",
            "description": "either midi or soir "
        },
        "waiterIds": {
            "type": "array",
            "items": { "$ref": "#/waiters/userId" },
            "description": "array of userIds field in waiters objects"
        },
        "doublerIds": {
            "type": "array",
            "items": { "$ref": "#/waiters/userId" },
            "description": "array of userIds field in waiters objects"
        }
    }
}
\end{minted}
\caption{JSON Schema Services}
\label{schema:services}
\end{listing}

On constate qu'un service doit au moins avoir un serveur. L'objet \textit{Waiter} n'est pas stocké en tant que tel mais juste le \textit{userId} qui le représente. 

En d'autres termes, les service "ont" des serveurs. Dans un premier temps la relation \textit{many-to-many}, i.e que les serveurs "aïent" eux aussi des services fut envisagée. Cependant, cette pratique est déconseillé dans les bases de données non relationnelles. Ainsi la documentation de Real Time Database conseille d'applatir les données. 
\newpage
\subsection*{Pool}
Cet objet représente les éléments mis en bourse. Ainsi ils sont crées quand une demande de remplacement ou de doublage est faite. Chacun des élément respect le schéma suivant:
\begin{listing}[!h]
\begin{minted}[fontsize=\scriptsize]{json}
{
    "title": "Pool",
    "type": "object",
    "required": [ "needValidation", "type", "urgence", "serviceId" ],
    "properties": {
        "needValidation": {
            "type": "bool",
            "description": "true if poolItem needs to be validated by a priviledged user"
        },
        "id":{
            "type": "String",
            "description": "autogenerated id of the pool"
        },
        "type": {
            "type": "String",
            "description": "either service or doubler"
        },
        "urgence": {
            "type": "String",
            "description": "high or medium or low"
        },
        "applicantsIds": {
            "type": "array",
            "items": { "$ref": "#/waiters/userId" },
            "description": "array of userIds field in waiters objects"
        },
        "selectedAppId": {
            "type": "String",
            "description": "userId of the selected applicant"
        },
        "serviceId": {
            "type": "String",
            "description": "id of the service where someone needs to be replaced or looking for doublers"
        }
    }
}
\end{minted}
\caption{JSON Schema Pool}
\label{schema:services}
\end{listing}

On voit que dans la base de données, il y a l'attribut \textit{needValidation}. Celui-ci est modifié lorsqu'un remplaçant a été accépté. Le champs \textit{applicantsIds} et \textit{selectedAppId} ne sont pas obligatoires. Ils sont ajouté seulement lorsque des utilisateurs postulent au service mis en bourse.

\subsection{La méthodologie REST}
En l'an 2000 Roy Thomas Fielding publie sa thèse \textit{Architectural Styles and the Design of Network-based Software Architectures} qui entre autres définit le standard \textit{Representational State Transfer} élégament abrégé \textit{REST}. Dans cette thèse, M. Fielding fait le constat qu'il existe essentiellement deux façons de concevoir une architecture software:
\begin{itemize}
    \item Tableau blanc où l'architecte donne libre cours à son imagination pour concevoir un système à base de composants qui lui sont familiers.
    \item À partir d'un système donné sans contraintes mais avec des besoins connus où l'architecte va graduellement cerner et appliquer des contraintes au système.  
\end{itemize}
\smallskip
Concernant les services web, M.Fielding conçoit \textit{REST} en identifiant les contraintes suivantes: 
\smallskip
\begin{itemize}
    \item \textbf{Client-Server} : l'interface utilisateur et séparée du stockage des données.
    \item \textbf{Stateless} : le serveur ne garde pas d'état concernant les clients. En d'autre termes, lorsqu'une requête est addréssée au serveur, elle contient toutes les informations nécéssaires pour y répondre.
    \item \textbf{Cache} : le serveur définit explicitement ou implicitement si les données d'une requête sont \textit{cacheable}. Si elles le sont, alors le client en garde une copie temporaire suite à une requête. Evitant ainsi des répétitions de requêtes. L'avantage est que le système est plus performant car les requêtes sont réduites. L'inconvénient et que l'état des données dans le serveur et chez le client peut différer.
    \item \textbf{Uniform Interface} : le serveur et le client suivent un protocole pour intéragir avec les données. Deux composants de base forment cette contrainte:
    \smallskip
    \begin{itemize}
        \item \textbf{Identification} : toutes les ressources sont uniquement identifiées.
        \item \textbf{Manipulation} : un ensemble d'opérations sur les données dont les résultat sont prévisibles.
    \end{itemize}
    \smallskip
    \item \textbf{Layered} : L'enseble du service offert est composé de couches indépendantes et communicantes entre elles.
\end{itemize}
\smallskip

Dans ce travail, l'application respecte les contraintes \textit{REST}. Concernant l'interface uniforme, le protocole \textit{http} a été utilisé. Dans la \textit{Real time database}, les verbes \textit{http} on le sens suivant.
\smallskip
\begin{itemize}
    \item [GET] permet d'acceder à une ressource. Ne modifie pas les ressources.
    \item [POST] création d'une ressource dans une liste de données. La base de données génère automatiquement un identifiant unique pour ce nouvel élément.
    \item [PUT] permet d'écrire ou de remplacer une ressource pour une chemin donné.
    \item [PATCH] permet de modifier partiellement une ressource.
    \item [DELETE] supprime une ressource.
\end{itemize}
\smallskip 
Dans ce contexte, le terme ressource représente toujours un objet JSON.


\subsection{REST appliqué à Dart}
Dans ce projet, plusieurs models on été définit du côté client. Ces models sont extrêmement similaires aux formats JSON qui doivent être respéctés du côté serveur. Ils fonctionnent par doublet, c'est-à-dire, qu'il y a le model qui représente une unité et celui qui représente une liste d'objects. Ces derniers, on déjà été brièvement traités dans la partie \textit{ChangeNotifier}. 

Les models: \textit{Waiter}, \textit{Service} et \textit{PoolItem} sont la partie unitaire de \textit{Waiters}, \textit{Services} et \textit{Pool} respectivement.

Leur structure est fonctionnement sont similaires ainsi seul \textit{Service} et \textit{Services} vont être exposés dans ce rapport.

La classe \textit{Service}, comme dit précédement, n'est qu'une implémentation locale de l'objet JSON stocké dans la base de données. Ainsi elle a les attributs suivants:
\begin{listing}[!h]
\begin{minted}[fontsize=\scriptsize]{dart}
    class Service implements Comparable<Service> {
        final String _id;
        final DateTime _date;
        final ServiceType _type;
        final List<String> _waiterIds;
        final List<String> _doublerIds;
      
        Service(this._id, this._date, this._type, this._waiterIds, this._doublerIds);
    }
\end{minted}
\caption{Service class}
\label{code:servicesClass}
\end{listing}

Les attributs sont tous finaux. Le traît du bas est la façon en Dart de faire des attributs privés. Chaque objet de cette classe est immutable. Ces objets sont chargé depuis la base de données ou s'ils sont crée en locale, alors il seront envoyés à la base de données pour qu'elle soit mise-à-jour. 

Il est donc nécéssaires de disposer d'une traduction en JSON dans les deux sens. Voici le constructeur qui permet de construire une instance de Service avec un un JSON en argument.\\
\begin{listing}[!h]
\begin{minted}[fontsize=\scriptsize]{dart}
Service.fromJson(Map<String, dynamic> json)
: this._id = json['id'],
    this._date = DateTime.parse(json['date']),
    this._type = ServiceType(json['type']),
    this._waiterIds = json['waiterIds'] != null
        ? (json['waiterIds'] as Map<String, dynamic>).keys.toList()
        : [],
    this._doublerIds = json['doublerIds'] != null
        ? (json['doublerIds'] as Map<String, dynamic>).keys.toList()
        : [];
\end{minted}
\caption{JSON to Service instance}
\label{code:json2service}
\end{listing}\\
Dans \ref{schema:services} il est dit qu'il y a une liste d'ids pour les serveurs et une autre pour les ids des doubleurs. On constate ici que ce n'est pas exactement une liste mais un \textit{map}. En effet, la Real Time database gère les listes comme des pairs \{clef, valeur\} où les clefs sont les indexes de la liste. Le problème est que si l'on modifie ou supprime un élément de la liste, les indexes ne sont pas mis à jour. Il s'est avéré beacoup plus simple d'utiliser \textit{map} car chaque id peut être uniquement accessible et l'ensemble des données reste consistent après modificiations ou suppressions. On voit dans les lignes 6 et 9 de \ref{code:json2service} que seules les clefs, qui représentent les ids, du \textit{map} sont extraites. Les valeurs ne portant aucune information. 

Dans l'autre sens, la traduction d'une instance en objet JSON:

\begin{listing}[!h]
\begin{minted}[fontsize=\scriptsize]{dart}
Map<String, dynamic> toJson() => {
    'id': _id,
    'date': _date.toIso8601String(),
    'type': _type.toString(),
    'waiterIds': {for (var w in _waiterIds) w: true},
    'doublerIds': {for (var d in _doublerIds) d: true},
    };
\end{minted}
\caption{Service instance to JSON}
\label{code:service2json}
\end{listing}

Comme on le voit dans les lignes 5 et 6, les valeurs du \textit{map} sont juste des \textit{true} qui doivent être casté en string en interne.
Naturellement, JSON est un format qui n'accèpte que du texte. Ainsi, la date est formaté en ISO 8601\footnote{https://www.iso.org/iso-8601-date-and-time-format.html} et on demande la version \textit{toString()} du \textit{\_type}. \textit{\_type} est une instance de la classe \textit{ServiceType} qui \textit{override} a méthode \textit{toString()} présente dans toutes les classes.
\newpage
\subsection*{GET}
Maintenant que chaque élément est facilement traduisible en JSON, on peut faire des requêtes à la base de données. Voici comment les services sont chargés en local:

\begin{listing}[!h]
\begin{minted}[fontsize=\scriptsize]{dart}
Future<List<Service>> fetchService(String token) async {
    try {
        final response = await http.get(UrlManager.url_service + token);
        final extractedData = json.decode(response.body) as Map<String, dynamic>;

        if (extractedData == null) {
            _services.clear();
            return [];
        }

        final List<Service> loadedData = [];
        extractedData.forEach((_, value) {
            loadedData.add(Service.fromJson(value));
        });

        _services = loadedData..sort();
        isLoaded = true;

        notifyListeners();
        return _services;
    } catch (error) {
        print("[fetchService]:: " + error.toString());
        throw error;
    }
}    
\end{minted}
\caption{Fetch services}
\label{code:fetchService}
\end{listing}

la méthode \textit{fetchService} de la classe \textit{Services} (attention au "s") prend un token en argument. Il s'agit d'un paramètre nécéssaire pour l'authentification qui sera traîté plus en détails dans la section suivante. C'est une méthode asynchrone qui dans un future retournera une liste de services. Au travers de \textit{http} qui est un ensemble de classe disponibles dans le package http l'on fait appel à la méthode \textit{http.get} avec l'url des services. L'objet retourné est de type JSON, il faut donc en extraire le corps et le \textit{caster} en \textit{map}.

Après s'être assuré que la réponse contient bel et bien des données, lignes 8 à 11, on extrait les données, en utilisant le constructeur définit dans \ref{code:json2service}, dans la variable loadedData. 

La Real Time database à cause du format JSON ne garantit pas l'ordre. Ainsi, les services sont triés par date en ordre croissant. D'où l'implémentation de la l'interface \textit{Comparable} que l'on voit dans \ref{code:servicesClass}.


\newpage
\section{Authentification}
Afin d'authentifier les requêtes à la base de données, il faut disposer d'un token. Celui-ci s'obtient comme pour créer de nouveau utilisateurs à traves une requête POST à une URL administrateur. Cette requête doit contenir dans son corps, l'email et le mot de passe. Si ceux-ci sont correctes, un token et retourné. 
\begin{listing}[!h]
    \begin{minted}[fontsize=\scriptsize]{dart}
Future<void> _authenticate(String email, String password, String url) async {
    try {
        final response = await http.post(
            url,
            body: json.encode(
             {
                'email': email,
                'password': password,
                'returnSecureToken': true,
             },
            ),
        ); ///...
    }
    \end{minted}
    \caption{Token request}
    \label{code:authenticate}
    \end{listing}
Du côté serveur, il faut indiquer que seules les requêtes authentifiées sont permises. La Real Time Database offre un système de règles que l'on peut définir. Voici les règles qui empêchent de lire ou écrire dans la base de données sans s'être authentifié:

\begin{listing}[!h]
    \begin{minted}[fontsize=\scriptsize]{json}
{
    "rules": {
        ".read": "auth != null",
        ".write":"auth != null",
    }
}
    \end{minted}
    \caption{Database rulest}
    \label{code:rules}
    \end{listing}

Le token qui permet d'authentifier les requêtes est valable pendant une heure. Après quoi il expire.
